* PCESK
This is an implementation of an abstract CESK machine which supports
concurrent constructs (spawn/join), based on Matthew Might's
description of CESK machines (mainly from the papers [[http://matt.might.net/papers/vanhorn2010abstract.pdf][Abstracting
Abstract Machines]] and [[http://matt.might.net/papers/might2011pceks.pdf][A Family of Abstract Interpretations for Static
Analysis of Concurrent Higher-Order Programming]])
** Dependencies and compilation
The following OCaml packages are required:
  - ocamlgraph
  - oUnit
  - batteries

Those packages are installable using [[http://opam.ocamlpro.com/][OPAM]]:
#+BEGIN_SRC shell
opam install ocamlgraph oUnit batteries
#+END_SRC

To compile this project, you'll also need ocamlbuild (generally
provided with OCaml). It has been tested with OCaml 4.01, but should
probably work with older versions too. To compile, simply launch
=make=. To launch the test suite, execute =make test=.
** Usage
#+BEGIN_SRC shell
usage: ./main.byte [-v level] [-i input] [-g graph_output] [-k polyvariance]
        [-t1 tag] [-t2 tag] [-target target] [other flags (see below)]
  -v : verbose level (0 by default)
  -i : input file (stdin by default)
  -g : output file for the generated graph (nothing by default)
  -k : polyvariance (k-CFA) (k=0 by default)
  -gc : turn on abstract garbage collection (disabled by default)
  -no-store-strong-updates : turn off strong updates in the store
  -p : turn on parallelism with spawn and join (disabled by default)
  -r : remove threads when they halt (disabled by default)
  -no-threads-strong-updates : turn off strong updates for the threads
  -quiet : don't print the results nor the parameters used, only the time and graph size
  -t1 : tag corresponding to the first expression used for MHP analysis
  -t2 : tag corresponding to the second expression used for MHP analysis
  -target {run|ast|mhp}: action to do with the input (run by default)
  -help  Display this list of options
  --help  Display this list of options
#+END_SRC

Those parameters are explained in more details below.

The results computed will be printed, one per line (multiple results
can computed). Generally, those different results will be merged
together to obtain a unique result.

The last line printed contains the number of nodes in the state
graph, the number of edges, and the time it took to compute it.

For example, the following examples calls a recursive function that
decrements a counter until it reaches 0, and then return the string
"done":
#+BEGIN_SRC shell
$ ./main.byte -i input/count.scm -gc
Running with:
        k = 0
        gc = on
Str
Str
49/49/0.008
#+END_SRC

*** General Parameters
  - =-v=: when the verbose mode is activated (> 0), the execution will
    also print a trace of the states computed (before the results),
    with eval states being printed in red, and continuation states
    being printed in green.
  - =-i=: indicates the input file from which to read the input. By
    default, standard input is read. For example input files, look at
    the =input/= directory.
  - =-g=: indicates where to write the state graph. Graphviz's dot
    format is used and images can be generated using =dot= (=dot -Tpng
    foo.dot > foo.png=).
  - =-quiet= disables the values outputted at the beginning of the
    execution.
  - =-p=: turns on parallelism (use PCESK instead of CESK), thus
    supporting =spawn= and =join=.
*** CESK Precision Parameters
  - =-k=: tune polyvariance (see Abstracting Abstract Machines), the
    higher the k, the higher the precision. However, for higher-order
    programs, k > 1 is not really useful.
  - =-gc=: activates abstract garbage collection. It will result in a
    much higher precision on complex programs.
  - =-no-store-strong-updates=: disable strong updates in the
    store. It should result in a loss of precision.
*** PCESK Precision Parameters
First, parallelism should be turned on with =-p= before using those
options.
  - =-r=: each times a thread halts, remove it from the thread
    map. It should result in a better precision.
  - =-no-threads-strong-updates=: disable strong updates in the
    thread map. It should result in a great loss of precision.
*** Targets
Multiple target (ie. actions to run) exists. Each target makes use of
the previously defined options.

The default target is =run=, which simply computes the state graph for
the given program.

The =ast= target allows the user to display the parsed AST, annotated
with tags (number corresponding to an AST node), in order to find the
tags to use for the =mhp= target.

The =mhp= target does a may-happen-in-parallel (MHP) analysis, using
the nodes described by the tags given by the =-t1= and =-t2=
parameters. For doing so, it computes the state graph and traverses it
in order to find a state where the two nodes can be evaluated. It then
prints whether they can be evaluated in parallel or not.

** Stuff to do
  - Abstract the thread ids
  - Improve modularity
    - fix the circular dependency between thread ids, cesk and pcesk
  - Weird behaviours
    - Disabling strong updates for the store *increases* the precision
    - Enabling garbage collection with parallelism *decreases* the precision
