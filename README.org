* PCESK
This is an implementation of an abstract CESK machine which will
support of parallel constructs (spawn/join), based on Matt Might's
description of CESK machines (mainly from the papers [[http://matt.might.net/papers/vanhorn2010abstract.pdf][Abstracting
Abstract Machines]] and [[http://matt.might.net/papers/might2011pceks.pdf][A Family of Abstract Interpretations for Static
Analysis of Concurrent Higher-Order Programming]])
** Dependencies and compilation
The following OCaml packages are required:
  - ocamlgraph
  - oUnit
  - batteries

Those packages are installable using [[http://opam.ocamlpro.com/][OPAM]]:
#+BEGIN_SRC shell
opam install ocamlgraph oUnit batteries
#+END_SRC

To compile this project, you'll also need ocamlbuild (generally
provided with ocaml). It has been tested with OCaml 4.01, but should
probably work with older versions too. To compile, simply launch
=make=. To launch the test suite, execute =make test=.
** Usage
#+BEGIN_SRC shell
usage: ./main.byte [-v level] [-i input] [-g graph_output] [-k polyvariance] [-gc] [-p] [-quiet]
  -v : verbose level (0 by default)
  -i : input file (stdin by default)
  -g : output file for the generated graph (nothing by default)
  -k : polyvariance (k-CFA) (k=0 by default)
  -gc : turn on abstract garbage collection (disabled by default)
  -p : turn on parallelism with spawn and join (disabled by default)
  -quiet : don't print the results nor the parameters used, only the time and graph size
  -help  Display this list of options
  --help  Display this list of options
#+END_SRC

When the verbose mode is activated, it will also print a trace of the
states computed (before the results), with eval states being printed
in red, and continuation states being printed in green.

When a graph output file is given (=-g=), a graph of the computed
states will be output in this file, using Graphviz's dot format. An
image file can then be generated (=dot -Tpng foo.dot > foo.png=)

The results computed will be printed, one per line (multiple
results can computed). Generally, those different results will be
merged together to obtain a unique result.

The last line printed contains the number of nodes in the state
graph, the number of edges, and the time it took to compute it.

For example:
#+BEGIN_SRC shell
$ ./main.byte -i input/count.scm -gc
Running with:
        k = 0
        gc = on
Str
Str
49/49/0.008
#+END_SRC
** Stuff to do
  - Implement spawn
  - Implement join
  - Abstract the thread ids
  - Don't push continuations when evaluating some atomic values
    (eg. (+ 1 2) can be evaluated in one step instead of 6)
